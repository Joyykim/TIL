# 아이템3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴이란: 인스턴스를 오직 하나만 생성할 수 있는 클래스.

예) 함수와 같은 무상태 객체 or 설계상 유일해야 하는 시스템 컴포넌트

단점: 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워짐. 타입을 인터페이스로 정의하고 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 mock 구현 객체로 대체할 수 없다.

## 싱글턴을 만드는 방법 3가지

### 1. public static final 필드

[예시 코드](https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter2/item3/field/Elvis.java)

public, protected 생성자가 없어서 다른 클래스에선 객체를 만들 수 없으므로 해당 인스턴스는 시스템에서 유일함이 보장된다. private 생성자만 있어서 상속이 불가하다. 해당 인스턴스가 싱글턴임이 API에 명확히 드러나고, 간결하다.

하지만 리플렉션 API를 사용해서 private 생성자에 접근할 수 있다. 이걸 방지하려면 private 생성자에서 두번째 인스턴스가 만들어질 때 예외를 발생시켜 막을 수 있다(싱글턴 인스턴스가 null이 아니라면 예외 발생).

### 2. 정적 팩토리 메서드

[예시 코드](https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter2/item3/staticfactory/Elvis.java)

- API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
- 정적 팩토리 메서드를 제네릭 싱글턴 팩토리로 만들 수 있다.
- 정적 팩토리의 메서드 참조를 `Supplier`로 사용할 수 있다. `Elvis::getInstance`를 `Supplier<Elvis>`로 사용.

리플렉션 API에 대한 약점은 `public static final 필드` 방식과 같다.

`public static final 필드`, `정적 팩토리 메서드` 두 방식 중 하나로 구현한 싱글턴 클래스는 직렬화할 때 Serializable 인터페이스 구현 이외의 추가작업이 필요하다.

### 3. 원소가 하나인 enum 타입

[예시 코드](https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter2/item3/enumtype/Elvis.java)

`public static final 필드` 방식과 비슷하지만 더 간결하고, 추가작업 없이 직렬화할 수 있다. 아주 복잡한 상황이나 리플렉션 API 공격에도 싱글턴을 완벽히 보장한다.

대부분의 상황에서는 enum 타입 싱글턴이 좋다. 하지만 다른 클래스를 상속해야 한다면 이 방법을 불가하다.(인터페이스를 구현하는건 가능)

